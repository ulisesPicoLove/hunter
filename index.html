<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Humbe runner</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap"
      rel="stylesheet" />
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        background: #111;
        font-family: "Roboto", sans-serif;
      }
      body {
        touch-action: manipulation;
        overscroll-behavior: none;
      }
      #wrap {
        min-height: 100vh;
        display: grid;
        place-items: center;
      }
      @supports (min-height: 100dvh) {
        #wrap {
          min-height: 100dvh;
        }
      }

      /* Canvas 16:9 responsive */
      canvas {
        display: block;
        border-radius: 12px;
        box-shadow: 0 10px 28px #0006;
        aspect-ratio: 16/9;
        width: min(100vw, calc(100vh * (16 / 9)));
        height: auto;
        max-width: 100vw;
        max-height: 100vh;
      }
      @supports (width: 100svw) {
        canvas {
          width: min(100svw, calc(100svh * (16 / 9)));
          max-width: 100svw;
          max-height: 100svh;
        }
      }
      @supports (width: 100dvw) {
        canvas {
          width: min(100dvw, calc(100dvh * (16 / 9)));
          max-width: 100dvw;
          max-height: 100dvh;
        }
      }

      .hud {
        position: fixed;
        top: 10px;
        left: 0;
        right: 0;
        display: flex;
        justify-content: center;
        gap: 8px;
        pointer-events: none;
      }
      .card {
        background: #fff;
        color: #222;
        padding: 6px 10px;
        border-radius: 12px;
        font-weight: 700;
      }
      /* Bot√≥n de sonido s√≠ recibe clics */
      #muteBtn {
        pointer-events: auto;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        user-select: none;
      }
      #muteBtn[aria-pressed="true"] {
        background: #222;
        color: #ffd33d;
        outline: 2px solid #ffd33d;
      }

      .overlay {
        position: fixed;
        inset: 0;
        display: none;
        place-items: center;
        background: #0007;
        color: #fff;
        text-align: center;
        padding: 20px;
      }
      .overlay.show {
        display: grid;
      }
      .btn {
        display: inline-block;
        margin-top: 10px;
        padding: 10px 14px;
        border-radius: 12px;
        background: #ffd33d;
        color: #000;
        font-weight: 800;
        cursor: pointer;
        user-select: none;
      }
      .stats {
        font-weight: 700;
        font-size: 18px;
        margin: 8px 0 4px;
      }
      #jumpBtn {
        position: fixed;
        right: 14px;
        bottom: 14px;
        padding: 16px 18px;
        border-radius: 999px;
        background: #ffd33d;
        color: #000;
        font-weight: 900;
        box-shadow: 0 6px 18px #0006;
        user-select: none;
      }
      #title img {
        display: block;
        margin: 12px auto 0;
        max-width: min(92vw, 480px);
        height: auto;
      }
      @media (min-width: 720px) {
        #jumpBtn {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="wrap">
      <canvas id="game"></canvas>

      <div class="hud">
        <div class="card">Puntos <span id="points">0</span></div>
        <div class="card">Distancia <span id="meters">0</span> m</div>
        <div class="card">ü•á <span id="best">0</span></div>
        <button
          id="muteBtn"
          class="card"
          type="button"
          aria-pressed="false"
          aria-label="Silenciar sonido">
          üîä Sonido
        </button>
      </div>

      <div id="overlay" class="overlay">
        <div>
          <div id="title">
            <img
              src="assets/caza.webp"
              alt="Bienvenido a Humbe Runner"
              style="width: clamp(200px, 50%, 400px)" />
          </div>

          <p id="subtitle">
            Evita obst√°culos
            <img src="assets/BadCloud.webp" alt="" width="20" />
            <img src="assets/Rayo.webp" alt="" width="20" />
            y atrapa
            <img src="assets/Star.webp" width="20" alt="" />
            <img src="assets/GoodCloud.webp" width="20" alt="" />. <br />Toca /
            Espacio / ‚Üë para saltar. Doble salto habilitado.
          </p>
          <p id="stats" class="stats" style="display: none"></p>
          <div class="btn" id="startBtn">Jugar</div>
        </div>
      </div>

      <div id="jumpBtn" role="button" aria-label="Saltar">‚§¥Ô∏é</div>
    </div>

    <!-- BGM + SFX usando DOM <audio>. Las rutas son assets/*.mp3 -->
    <audio id="bgm" src="assets/sound.mp3" preload="auto" loop></audio>
    <audio id="sfxJump" src="assets/jump.mp3" preload="auto"></audio>
    <audio id="sfxStar" src="assets/collect.mp3" preload="auto"></audio>
    <audio id="sfxBonus" src="assets/point.mp3" preload="auto"></audio>
    <audio id="sfxOver" src="assets/lose.mp3" preload="auto"></audio>

    <!-- Script ORIENTACI√ìN + JUEGO -->
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // =============== Orientaci√≥n / Gate ===============
        (() => {
          const isTouch = () =>
            "ontouchstart" in window || navigator.maxTouchPoints > 0;
          const isMobileUA =
            /Android|iPhone|iPad|iPod|IEMobile|Opera Mini/i.test(
              navigator.userAgent
            );
          const isMobile = () => isTouch() && isMobileUA;
          const isPortrait = () =>
            window.matchMedia
              ? window.matchMedia("(orientation: portrait)").matches
              : window.innerHeight >= window.innerWidth;

          const overlay = document.createElement("div");
          overlay.id = "rotateOverlay";
          overlay.setAttribute("aria-hidden", "true");
          overlay.style.cssText =
            "position:fixed;inset:0;display:none;place-items:center;background:#000c;z-index:99999;color:#fff;text-align:center;padding:24px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;backdrop-filter:blur(2px)";
          overlay.innerHTML = `
            <div style="max-width:560px">
              <div style="font-size:64px;line-height:1;margin-bottom:12px">üîÅüì±</div>
              <h2 style="margin:0 0 6px;font-size:22px">Gira tu dispositivo</h2>
              <p style="margin:0;opacity:.9">Este juego solo funciona en <b>horizontal</b>.</p>
            </div>`;
          document.body.appendChild(overlay);

          const bgm = document.getElementById("bgm");
          const canvas = document.getElementById("game");
          let bgmWasPlaying = false;

          function show() {
            overlay.style.display = "grid";
            overlay.setAttribute("aria-hidden", "false");
            document.documentElement.style.pointerEvents = "none";
            overlay.style.pointerEvents = "auto";
            if (canvas) canvas.style.opacity = "0.001";
            if (bgm) {
              bgmWasPlaying = !bgm.paused;
              try {
                bgm.pause();
              } catch {}
            }
          }
          function hide() {
            overlay.style.display = "none";
            overlay.setAttribute("aria-hidden", "true");
            document.documentElement.style.pointerEvents = "";
            if (canvas) canvas.style.opacity = "";
            if (bgm && bgmWasPlaying) {
              bgm.play().catch(() => {});
            }
          }
          function applyGate() {
            if (!isMobile()) {
              hide();
              return;
            }
            if (isPortrait()) show();
            else hide();
          }

          async function requestLandscapeLock() {
            try {
              if (screen.orientation && screen.orientation.lock) {
                await screen.orientation.lock("landscape");
              }
            } catch {}
          }
          const startBtn = document.getElementById("startBtn");
          if (startBtn) {
            startBtn.addEventListener(
              "click",
              () => {
                requestLandscapeLock();
                setTimeout(applyGate, 0);
              },
              { passive: true }
            );
          }

          window.addEventListener("resize", applyGate, { passive: true });
          window.addEventListener(
            "orientationchange",
            () => setTimeout(applyGate, 100),
            { passive: true }
          );
          if (window.visualViewport) {
            visualViewport.addEventListener(
              "resize",
              () => setTimeout(applyGate, 0),
              { passive: true }
            );
          }
          document.addEventListener("visibilitychange", () => {
            if (document.visibilityState === "visible") applyGate();
          });

          applyGate();
          window.__applyOrientationGate = applyGate;
        })();

        // =============== Juego ===============
        (() => {
          // ---------- Canvas ----------
          const c = document.getElementById("game");
          const ctx = c.getContext("2d", { alpha: true });

          const V = { W: 960, H: 540, aspect: 16 / 9 };

          let DPR = 1,
            SCALE = 1;
          function getViewportSize() {
            const vw = Math.floor(
              window.visualViewport?.width ?? window.innerWidth
            );
            const vh = Math.floor(
              window.visualViewport?.height ?? window.innerHeight
            );
            return { vw, vh };
          }
          function fit() {
            DPR = Math.min(2, window.devicePixelRatio || 1);
            const { vw, vh } = getViewportSize();
            SCALE = Math.min(vw / V.W, vh / V.H);
            c.style.width = V.W * SCALE + "px";
            c.style.height = V.H * SCALE + "px";
            c.width = Math.round(V.W * DPR);
            c.height = Math.round(V.H * DPR);
            ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
          }
          addEventListener("resize", fit, { passive: true });
          addEventListener("orientationchange", fit, { passive: true });
          if (window.visualViewport)
            visualViewport.addEventListener("resize", fit, { passive: true });
          fit();

          // Helpers
          const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
          const rand = (a, b) => a + Math.random() * (b - a);
          function safeDraw(imgEl, ...args) {
            if (!imgEl || !imgEl.complete || imgEl.naturalWidth === 0) return;
            ctx.drawImage(imgEl, ...args);
          }
          function bubbleTarget() {
            const p = S.player;
            return { x: p.x + p.w * 0.55, y: p.y - p.h - 50 };
          }

          // ---------- ASSETS ----------
          const assets = {
            bg: "assets/SkyBack.webp",
            ground: "assets/baseFront.webp",
            groundFront: "assets/base.webp",
            star: "assets/Star.webp",
            starBonus: "assets/GoodCloud.webp",
            obstacle: "assets/Rayo.webp",
            meteor: "assets/meteorito.webp",
            bird: "assets/BadCloud.webp",
            player: {
              runL: "assets/Humbeleft.webp",
              runR: "assets/HumbeRigth.webp",
              jump: "assets/HumbeJump.webp",
            },
            gameOverImg: "assets/GAMEOVER.webp",
          };
          const METEOR_W = 500,
            METEOR_H = 401,
            METEOR_AR = METEOR_W / METEOR_H;
          const PLAYER_VOFFSET = 6,
            BLOCK_VOFFSET = 6;

          function loadImage(src) {
            const i = new Image();
            i.src = src;
            return i;
          }
          const img = {
            bg: loadImage(assets.bg),
            ground: loadImage(assets.ground),
            groundFront: loadImage(assets.groundFront),
            star: loadImage(assets.star),
            starBonus: loadImage(assets.starBonus),
            obstacle: loadImage(assets.obstacle),
            meteor: loadImage(assets.meteor),
            bird: loadImage(assets.bird),
            player: {
              runL: loadImage(assets.player.runL),
              runR: loadImage(assets.player.runR),
              jump: loadImage(assets.player.jump),
            },
          };

          // ---------- F√≠sica / Juego ----------
          const G = {
            gravity: 2200,
            jumpV: 860,
            groundY: () => V.H * 0.78,
            baseSpeed: 290,
            maxSpeed: 1000,
            speedUpEach: 14,
            speedUpDelta: 28,
            starEvery: [1.0, 2.0],
            obsEvery: [1.5, 3.2],
          };
          const BONUS = {
            prob: 0.18,
            speedMul: 1.4,
            ampX: 18,
            ampY: 66,
            freq: 1.8,
            driftY: -12,
            jitter: 22,
          };
          const STAR_SIZE = { collisionR: 18, visualScale: 1 };
          const BONUS_SIZE = { collisionR: 22, visualW: 3, visualH: 1.2 };

          // ---------- Frases (bubble) ----------
          const PHRASES = Array.isArray(window.PHRASES)
            ? window.PHRASES
            : [
                "¬°Lo que tocas, oro se hace!",
                "¬°Eres lo que el Sol siempre quiso ser!",
                "¬°Ponte cerca pa‚Äô dec√≠rtelo al o√≠do: te necesito!",
                "¬°Yo espero por tu llegada!",
                "¬°Tan fr√≠o y aun as√≠ me arde!",
                "¬°Por ti, yo muevo el planeta completo!",
                "¬°Si el amor no quema, no es amar!",
                "¬°No me temas, soy extraordinario!",
                "¬°D√©jame, en besos, recorrer tu piel!",
                "¬°Nos hacemos eternos!",
                "¬°T√∫ eres para m√≠!",
                "¬°Contigo, yo volv√≠ a respirar!",
                "¬°Amarrado en tus besos y en tu piel!",
                "¬°Diez mil kil√≥metros descalzo correr√≠a, todo dar√≠a por que fueras m√≠a!",
                "¬°A veces, no me siento yo!",
                "¬°Ten la confianza y busca la vida!",
                "¬°Respira, que todo se alivia!",
                "¬°Perderte es vivir sin mi propia esencia!",
                "¬°El tiempo pasa r√°pido y lento!",
                "¬°Necesito volver a encontrarte!",
              ];
          function makeShuffledBag(arr) {
            const a = (Array.isArray(arr) ? arr : []).filter((v) => v != null);
            for (let i = a.length - 1; i > 0; i--) {
              const j = (Math.random() * (i + 1)) | 0;
              [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
          }

          // ---------- üîä AUDIO (toggle con dos estados unificado) ----------
          const muteBtn = document.getElementById("muteBtn");
          const bgm = document.getElementById("bgm");

          // Estado global de audio
          let audioReady = false;
          let muted = localStorage.getItem("humbe_muted") === "1";

          // Volumen maestro
          const MASTER_VOLUME = 0.25;

          // Actualiza el bot√≥n (texto, aria-pressed y aria-label)
          function updateMuteButton() {
            if (!muteBtn) return;
            if (muted) {
              muteBtn.setAttribute("aria-pressed", "true");
              muteBtn.setAttribute("aria-label", "Activar sonido");
              muteBtn.textContent = "üîá Sonido desactivado";
            } else {
              muteBtn.setAttribute("aria-pressed", "false");
              muteBtn.setAttribute("aria-label", "Silenciar sonido");
              muteBtn.textContent = "üîä Sonido activado";
            }
          }

          // Aplica el estado a BGM y SFX
          function applyMuteState() {
            if (bgm) {
              bgm.muted = muted;
              if (muted) {
                try {
                  bgm.pause();
                } catch {}
              } else if (audioReady) {
                bgm.volume = MASTER_VOLUME;
                bgm.play().catch(() => {});
              }
            }
            ["sfxJump", "sfxStar", "sfxBonus", "sfxOver"].forEach((id) => {
              const a = document.getElementById(id);
              if (a) a.muted = muted;
            });
          }

          // Click: alterna mute ‚áÑ unmute
          if (muteBtn) {
            muteBtn.addEventListener("click", () => {
              muted = !muted;
              localStorage.setItem("humbe_muted", muted ? "1" : "0");
              updateMuteButton();
              applyMuteState();
            });
          }

          // Primeo silencioso para SFX
          function primeAudioEl(a) {
            if (!a) return;
            const vol = a.volume;
            a.volume = 0;
            a.currentTime = 0;
            a.play()
              .then(() => {
                a.pause();
                a.currentTime = 0;
                a.volume = vol;
              })
              .catch(() => {
                a.volume = vol;
              });
          }

          // Desbloquea audio tras primera interacci√≥n
          async function unlockAudio() {
            if (audioReady) return;
            audioReady = true;
            try {
              ["sfxJump", "sfxStar", "sfxBonus", "sfxOver"].forEach((id) => {
                const a = document.getElementById(id);
                if (a) {
                  a.volume = MASTER_VOLUME;
                  primeAudioEl(a);
                }
              });

              if (bgm) {
                bgm.volume = MASTER_VOLUME;
                bgm.muted = muted;
                if (!muted) {
                  await bgm.play().catch(() => {});
                }
              }
            } catch (err) {
              console.warn("Error al iniciar audio:", err);
            }
            updateMuteButton();
          }

          // Gesto de puntero desbloquea audio (incluye ‚Äúprimeo‚Äù seguro)
          window.addEventListener(
            "pointerdown",
            () => {
              if (!bgm) {
                unlockAudio();
                applyMuteState();
                return;
              }
              const vol = bgm.volume;
              bgm.volume = 0;
              bgm
                .play()
                .then(() => {
                  bgm.pause();
                  bgm.currentTime = 0;
                  bgm.volume = vol;
                  unlockAudio();
                  applyMuteState();
                })
                .catch(() => {
                  unlockAudio();
                  applyMuteState();
                });
            },
            { once: true, passive: true }
          );

          // Teclas tambi√©n desbloquean audio
          window.addEventListener(
            "keydown",
            (e) => {
              if (["Enter", "Space", "ArrowUp"].includes(e.code)) {
                unlockAudio();
                applyMuteState();
              }
            },
            { once: true }
          );

          // Reproductor de SFX (respeta muted y audioReady)
          function playSfx(id) {
            if (muted || !audioReady) return;
            const a = document.getElementById(id);
            if (!a) return;
            try {
              a.currentTime = 0;
              a.volume = MASTER_VOLUME;
              a.play().catch(() => {});
            } catch {}
          }

          // Inicial: refleja preferencia guardada
          updateMuteButton();
          applyMuteState();
          // ---------- /AUDIO ----------

          // 1) Desbloqueo en el primer gesto del usuario
          window.addEventListener(
            "pointerdown",
            () => {
              const bgm = document.getElementById("bgm");
              if (!bgm) return;
              // Primeo iOS/Safari
              const vol = bgm.volume;
              bgm.volume = 0;
              bgm
                .play()
                .then(() => {
                  bgm.pause();
                  bgm.currentTime = 0;
                  bgm.volume = vol;
                  bgm.muted = false;
                  bgm.volume = 0.5;
                  bgm.play().catch(() => {});
                })
                .catch(() => {
                  // Si el primeo falla, intenta reproducir directo tras el gesto
                  bgm.muted = false;
                  bgm.volume = 0.5;
                  bgm.currentTime = 0;
                  bgm.play().catch(() => {
                    /* opcional: mostrar un aviso */
                  });
                });
            },
            { once: true, passive: true }
          );

          // Si usas tecla:
          window.addEventListener(
            "keydown",
            (e) => {
              if (["Enter", "Space", "ArrowUp"].includes(e.code)) {
                const ev = new PointerEvent("pointerdown");
                window.dispatchEvent(ev);
              }
            },
            { once: true }
          );

          // Reprod. SFX unificada
          function playSfx(id) {
            if (muted || !audioReady) return;
            const a = document.getElementById(id);
            if (!a) return;
            try {
              a.currentTime = 0;
              a.play();
            } catch {}
          }

          // ---------- Estado ----------
          let S;
          let canRestartAt = 0;

          function reset() {
            S = {
              t: 0,
              running: false,
              score: 0,
              meters: 0,
              stars: 0,
              best: Number(localStorage.getItem("bestPoints") || 0),
              speed: G.baseSpeed,
              lastStar: 0,
              lastObs: 0,
              lastSpeedUp: 0,
              jumps: 0,
              player: {
                x: 120,
                y: G.groundY(),
                w: 72,
                h: 72,
                vy: 0,
                onGround: true,
                state: "runL",
                frameTimer: 0,
                runFps: 10,
              },
              obs: [],
              items: [],
              particles: [],
              front: {
                x: 0,
                speedMul: 1.15,
                y: G.groundY() - 0,
                h: 120,
                alpha: 1,
              },
              groundScroll: { x: 0, y: V.H * 0.66, h: 120, speedPx: 80 },
              bubble: null,
              phraseBag: makeShuffledBag(PHRASES || []),
            };
          }
          reset();

          function nextPhrase() {
            if (!Array.isArray(PHRASES) || PHRASES.length === 0) return "";
            if (!S.phraseBag || S.phraseBag.length === 0) {
              S.phraseBag = makeShuffledBag(PHRASES);
            }
            const msg = S.phraseBag.pop();
            return typeof msg === "string" ? msg : "";
          }

          // ---------- Input ----------
          function jump() {
            if (!S.running) return;
            const p = S.player;
            if (p.onGround || S.jumps < 2) {
              p.vy = -G.jumpV;
              p.onGround = false;
              S.jumps++;
              p.state = "jump";
              // sonido de salto
              playSfx("sfxJump");
            }
          }
          addEventListener("keydown", (e) => {
            if (["Space", "Enter", "ArrowUp"].includes(e.code))
              e.preventDefault();
            if (e.code === "ArrowUp") {
              unlockAudio();
              jump();
            }
            if (!S.running && (e.code === "Space" || e.code === "Enter")) {
              if (performance.now() >= canRestartAt) {
                unlockAudio();
                start();
              }
            }
          });
          c.addEventListener("pointerdown", (e) => {
            e.preventDefault();
            if (S.running) {
              unlockAudio();
              jump();
            }
          });

          // Bot√≥n t√°ctil "Saltar"
          const jumpBtnEl = document.getElementById("jumpBtn");
          if (jumpBtnEl) {
            jumpBtnEl.addEventListener("pointerdown", (e) => {
              e.preventDefault();
              unlockAudio();
              if (S.running) jump();
            });
          }

          const overlay = document.getElementById("overlay");
          const subtitleEl = document.getElementById("subtitle");
          const statsEl = document.getElementById("stats");
          const startBtn = document.getElementById("startBtn");
          if (startBtn)
            startBtn.onclick = () => {
              unlockAudio();
              start();
            };

          if (overlay) {
            overlay.addEventListener("pointerdown", () => {
              if (!S.running && performance.now() >= canRestartAt) {
                unlockAudio();
                start();
              }
            });
          }

          const rewardBtn = (() => {
            let btn = document.getElementById("rewardBtn");
            if (!btn && overlay) {
              btn = document.createElement("div");
              btn.id = "rewardBtn";
              btn.className = "btn";
              btn.style.display = "none";
              btn.textContent = "Recompensa ";
              btn.onclick = () => {
                if (!S.running && performance.now() >= canRestartAt) start();
              };
              const container = overlay.firstElementChild || overlay;
              container.appendChild(btn);
            }
            return btn;
          })();

          // ---------- Spawns ----------
          function spawn(dt) {
            S.lastStar += dt;
            S.lastObs += dt;
            S.lastSpeedUp += dt;

            if (S.lastSpeedUp >= G.speedUpEach) {
              S.speed = Math.min(G.maxSpeed, S.speed + G.speedUpDelta);
              S.lastSpeedUp = 0;
            }

            if (S.lastStar >= rand(...G.starEvery)) {
              const isBonus = Math.random() < BONUS.prob;
              S.items.push({
                type: isBonus ? "bonus" : "star",
                x: V.W + 40,
                y: rand(V.H * 0.5, V.H * 0.72),
                r: isBonus ? BONUS_SIZE.collisionR : STAR_SIZE.collisionR,
                vScale: isBonus ? 1 : STAR_SIZE.visualScale || 1,
                vW: isBonus ? BONUS_SIZE.visualW || 3.2 : 0,
                vH: isBonus ? BONUS_SIZE.visualH || 1.6 : 0,
                vx: S.speed * (isBonus ? BONUS.speedMul : 1.0),
                t: 0,
                phase: rand(0, Math.PI * 2),
                ampX: BONUS.ampX * rand(0.6, 1.4),
                ampY: BONUS.ampY * rand(0.6, 1.4),
                freq: BONUS.freq * rand(0.7, 1.3),
                driftY: BONUS.driftY * rand(0.6, 1.4),
                jitter: BONUS.jitter,
              });
              S.lastStar = 0;
            }

            if (S.lastObs >= rand(...G.obsEvery)) {
              const r = Math.random();
              if (r < 0.55) {
                S.obs.push({
                  type: "block",
                  x: V.W + 40,
                  y: G.groundY(),
                  w: 60,
                  h: 60,
                  vx: S.speed,
                });
              } else if (r < 0.85) {
                S.obs.push({
                  type: "bird",
                  x: V.W + 40,
                  y: rand(V.H * 0.52, V.H * 0.64),
                  w: 60,
                  h: 40,
                  vx: S.speed,
                  flap: 0,
                });
              } else {
                const startX = rand(V.W * 0.7, V.W + 80),
                  startY = rand(-120, -40);
                const speed = rand(380, 520),
                  fall = rand(280, 380);
                const destH = 26 * 2.3,
                  destW = destH * METEOR_AR;
                S.obs.push({
                  type: "meteor",
                  x: startX,
                  y: startY,
                  vx: speed,
                  vy: fall,
                  dw: destW,
                  dh: destH,
                  rcx: -0.24,
                  rcy: 0.08,
                  rr: 0.18,
                });
              }
              S.lastObs = 0;
            }
          }

          // ---------- Colisiones / part√≠culas ----------
          const clampR = (cx, cy, r, rx, ry, rw, rh) => {
            const nx = clamp(cx, rx, rx + rw),
              ny = clamp(cy, ry, ry + rh);
            const dx = cx - nx,
              dy = cy - ny;
            return dx * dx + dy * dy <= r * r;
          };
          const aabb = (a, b) =>
            a.x < b.x + b.w &&
            a.x + a.w > b.x &&
            a.y < b.y + b.h &&
            a.y + a.h > b.y;

          function puff(x, y, n = 6) {
            for (let i = 0; i < n; i++) {
              S.particles.push({
                type: "note",
                x,
                y,
                vx: rand(-120, 120),
                vy: rand(-220, -80),
                s: rand(18, 28),
                rot: rand(-0.35, 0.35),
                life: rand(0.8, 1.2),
              });
            }
          }

          // ---------- Loop ----------
          let last = performance.now();
          function loop(now) {
            try {
              const dt = Math.min((now - last) / 1000, 0.033);
              last = now;
              if (S.running) update(dt);
              draw();
            } catch (err) {
              console.error(err);
              const overlay = document.getElementById("overlay");
              const statsEl = document.getElementById("stats");
              if (overlay) overlay.classList.add("show");
              if (statsEl) {
                statsEl.style.display = "block";
                statsEl.textContent =
                  "Error: " + (err && err.message ? err.message : String(err));
              }
            }
            requestAnimationFrame(loop);
          }
          requestAnimationFrame(loop);

          function update(dt) {
            S.t += dt;
            S.meters += S.speed * dt * 0.06;

            if (S.bubble && S.bubble.lockToPlayer) {
              const t = bubbleTarget();
              const followSpeed = 12;
              S.bubble.x += (t.x - S.bubble.x) * Math.min(1, dt * followSpeed);
              S.bubble.y += (t.y - S.bubble.y) * Math.min(1, dt * followSpeed);
              S.bubble.x = clamp(S.bubble.x, 16, V.W - 16);
              S.bubble.y = clamp(S.bubble.y, 16, V.H - 16);
            }

            const p = S.player;
            // f√≠sica
            p.vy += G.gravity * dt;
            p.y += p.vy * dt;
            if (p.y > G.groundY()) {
              p.y = G.groundY();
              p.vy = 0;
              p.onGround = true;
              S.jumps = 0;
              if (p.state === "jump") p.state = "runL";
            } else p.onGround = false;

            // animaci√≥n
            if (p.onGround) {
              p.frameTimer += dt;
              if (p.frameTimer >= 1 / p.runFps) {
                p.state = p.state === "runL" ? "runR" : "runL";
                p.frameTimer = 0;
              }
            } else p.state = "jump";

            spawn(dt);

            // mover obs/items
            S.obs.forEach((o) => {
              if (o.type === "bird" || o.type === "block") {
                o.x -= o.vx * dt;
                if (o.type === "bird") {
                  o.flap += dt * 9;
                  o.y += Math.sin(S.t * 4 + o.x * 0.02) * 0.6;
                }
              } else if (o.type === "meteor") {
                o.x -= o.vx * dt;
                o.y += o.vy * dt;
              }
            });
            S.items.forEach((i) => {
              i.x -= i.vx * dt;
              if (i.type === "bonus") {
                i.t += dt;
                i.x += Math.cos(i.phase + i.t * i.freq) * (i.ampX * dt);
                i.y += Math.sin(i.phase * 0.7 + i.t * i.freq) * (i.ampY * dt);
                i.y += i.driftY * dt;
                if (Math.random() < 0.05)
                  i.y += rand(-i.jitter, i.jitter) * 0.05;
                i.y = clamp(i.y, V.H * 0.35, V.H * 0.78);
              }
            });

            // mover capa frontal
            S.front.x -= S.speed * S.front.speedMul * dt;
            if (S.front.x <= -V.W) S.front.x += V.W;

            // mover ground independiente
            S.groundScroll.x -= S.groundScroll.speedPx * dt;
            if (S.groundScroll.x <= -V.W) S.groundScroll.x += V.W;

            // jugador rect colisi√≥n
            const pr = {
              x: p.x + p.w * 0.15,
              y: p.y - p.h + 5,
              w: p.w * 0.7,
              h: p.h - 10,
            };

            // estrellas (normal/bonus)
            for (let i = S.items.length - 1; i >= 0; i--) {
              const s = S.items[i];
              if (clampR(s.x, s.y, s.r, pr.x, pr.y, pr.w, pr.h)) {
                S.stars++;
                if (s.type === "bonus") {
                  S.score += 120;
                  puff(s.x, s.y, 8);
                  S.particles.push({
                    x: s.x,
                    y: s.y - 60,
                    vx: 0,
                    vy: 0,
                    r: 0,
                    life: 0.8,
                    text: "+120",
                    color: "#2519e3",
                    stroke: "#3b2f00",
                  });
                  playSfx("sfxBonus");
                } else {
                  S.score += 10;
                  puff(s.x, s.y, 5);
                  playSfx("sfxStar"); // ‚¨ÖÔ∏è ahora suena collect
                }

                if (S.stars % 4 === 0) {
                  const msg = nextPhrase();
                  const t = bubbleTarget();
                  S.bubble = {
                    text: msg,
                    time: 3.3,
                    x: t.x,
                    y: t.y,
                    lockToPlayer: true,
                  };
                }
                S.items.splice(i, 1);
              } else if (s.x < -80) S.items.splice(i, 1);
            }

            // colisiones letales
            for (const o of S.obs) {
              if (o.type === "meteor") {
                const mw = o.dw ?? (o.dh ? o.dh * METEOR_AR : METEOR_W);
                const mh = o.dh ?? (o.dw ? o.dw / METEOR_AR : METEOR_H);
                const cx = o.x + mw * (o.rcx ?? -0.24);
                const cy = o.y + mh * (o.rcy ?? 0.08);
                const rr = mh * (o.rr ?? 0.18);
                if (clampR(cx, cy, rr, pr.x, pr.y, pr.w, pr.h)) return over();
                continue;
              }
              const ob = {
                x: o.x + o.w * 0.1,
                y: o.y - o.h,
                w: o.w * 0.8,
                h: o.h,
              };
              if (aabb(pr, ob)) {
                if (o.type === "bird" && p.y < o.y - o.h / 2) continue;
                return over();
              }
            }

            // limpiar y part√≠culas
            S.obs = S.obs.filter((o) => o.x > -120 && o.y < V.H + 140);
            for (let i = S.particles.length - 1; i >= 0; i--) {
              const pa = S.particles[i];
              pa.life -= dt;
              if (pa.life <= 0) {
                S.particles.splice(i, 1);
                continue;
              }
              pa.x += pa.vx * dt;
              pa.y += pa.vy * dt;
              pa.vy += 900 * dt;
            }

            if (S.bubble) {
              S.bubble.time -= dt;
              if (S.bubble.time <= 0) S.bubble = null;
            }
          }

          // ---------- Dibujo ----------
          function drawMeteorProportional(o) {
            const m = img.meteor,
              iw = m.width || METEOR_W,
              ih = m.height || METEOR_H;
            const DW = o.dw ?? (o.dh ? o.dh * METEOR_AR : iw);
            const DH = o.dh ?? (o.dw ? o.dw / METEOR_AR : ih);
            safeDraw(m, 0, 0, iw, ih, o.x - DW / 2, o.y - DH / 2, DW, DH);
          }
          function drawTiled(image, x, y, h) {
            const tex =
              image && image.complete && image.naturalWidth
                ? image
                : img.ground;
            let x0 = Math.floor(x);
            while (x0 > 0) x0 -= V.W;
            for (let xx = x0; xx < V.W; xx += V.W) safeDraw(tex, xx, y, V.W, h);
          }
          function drawSpeechBubble(text, x, y, maxW = 220) {
            ctx.font = "bold 14px system-ui, Arial";
            const words = String(text).split(/\s+/);
            const lines = [];
            let line = "";
            for (const w of words) {
              const t = line ? line + " " + w : w;
              if (ctx.measureText(t).width <= maxW) line = t;
              else {
                if (line) lines.push(line);
                line = w;
              }
            }
            if (line) lines.push(line);
            const lh = 22,
              padX = 12,
              padY = 10;
            const w = Math.min(
              maxW,
              Math.max(...lines.map((t) => ctx.measureText(t).width)) + padX * 2
            );
            const h = lines.length * lh + padY * 2;
            const rx = x - w / 2,
              ry = y - h,
              r = 10;

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(rx + r, ry);
            ctx.lineTo(rx + w - r, ry);
            ctx.quadraticCurveTo(rx + w, ry, rx + w, ry + r);
            ctx.lineTo(rx + w, ry + h - r);
            ctx.quadraticCurveTo(rx + w, ry + h, rx + w - r, ry + h);
            const tipX = x + 12,
              tipY = ry + h + 8;
            ctx.lineTo(tipX, ry + h);
            ctx.lineTo(x, tipY);
            ctx.lineTo(x - 12, ry + h);
            ctx.lineTo(rx + r, ry + h);
            ctx.quadraticCurveTo(rx, ry + h, rx, ry + h - r);
            ctx.lineTo(rx, ry + r);
            ctx.quadraticCurveTo(rx, ry, rx + r, ry);
            ctx.closePath();

            ctx.shadowColor = "#0008";
            ctx.shadowBlur = 2;
            ctx.fillStyle = "#f2f2f2";
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#faf";
            ctx.stroke();

            ctx.fillStyle = "#111";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            let yy = ry + padY + lh / 2;
            for (const ln of lines) {
              ctx.fillText(ln, x, yy);
              yy += lh;
            }
            ctx.restore();
          }

          function draw() {
            ctx.clearRect(0, 0, V.W, V.H);

            // Fondo
            safeDraw(img.bg, 0, 0, V.W, V.H);

            // Ground independiente
            drawTiled(
              img.ground,
              S.groundScroll.x,
              S.groundScroll.y,
              S.groundScroll.h
            );

            // Estrellas / Bonus
            for (const s of S.items) {
              const isBonus = s.type === "bonus";
              const spr = isBonus ? img.starBonus : img.star;

              if (isBonus) {
                const vW = s.vW || 3.2,
                  vH = s.vH || 1.6;
                const w = s.r * vW,
                  h = s.r * vH;
                safeDraw(spr, s.x - w / 2, s.y - h / 2, w, h);
              } else {
                const scale = s.vScale || 1;
                const rr = s.r * scale;
                safeDraw(spr, s.x - rr, s.y - rr, rr * 2, rr * 2);
              }
            }

            // Obst√°culos
            for (const o of S.obs) {
              if (o.type === "bird") {
                safeDraw(img.bird, o.x, o.y - o.h, o.w, o.h);
              } else if (o.type === "meteor") {
                drawMeteorProportional(o);
              } else {
                safeDraw(
                  img.obstacle,
                  o.x,
                  o.y - o.h + BLOCK_VOFFSET,
                  o.w,
                  o.h
                );
              }
            }

            // Jugador
            const p = S.player;
            const sprite =
              p.state === "runL"
                ? img.player.runL
                : p.state === "runR"
                  ? img.player.runR
                  : img.player.jump;
            ctx.save();
            const tilt = p.onGround ? 0 : clamp(p.vy / 900, -0.6, 0.6);
            ctx.translate(p.x + p.w / 2, p.y - p.h / 2 + PLAYER_VOFFSET);
            ctx.rotate(tilt);
            safeDraw(sprite, -p.w / 2, -p.h / 2, p.w, p.h);
            ctx.restore();

            // Bubble
            if (S.bubble)
              drawSpeechBubble(S.bubble.text, S.bubble.x, S.bubble.y);

            // Part√≠culas
            for (const pa of S.particles) {
              ctx.globalAlpha = Math.max(0, Math.min(1, pa.life));
              if (pa.text) {
                ctx.font = "bold 20px system-ui, Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStyle = pa.color || "#a3f";
                ctx.fillText(pa.text, pa.x, pa.y);
              } else {
                ctx.save();
                ctx.translate(pa.x, pa.y);
                ctx.rotate(pa.rot || 0);
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = `bold ${Math.round(pa.s)}px system-ui, Apple Color Emoji, Segoe UI Emoji, Arial`;
                ctx.fillStyle = "#ffd33d";
                ctx.strokeStyle = "#c99b1a";
                ctx.lineWidth = 2;
                const glyph = "‚ô™";
                ctx.fillText(glyph, 0, 0);
                ctx.strokeText(glyph, 0, 0);
                ctx.restore();
              }
              ctx.globalAlpha = 1;
            }

            // Capa frontal
            drawTiled(img.groundFront, S.front.x, S.front.y, S.front.h);

            // HUD
            const pointsEl = document.getElementById("points");
            if (pointsEl) pointsEl.textContent = Math.floor(S.score);
            const metersEl = document.getElementById("meters");
            if (metersEl) metersEl.textContent = Math.floor(S.meters);
            const bestEl = document.getElementById("best");
            if (bestEl) bestEl.textContent = S.best;
          }

          // ---------- Ciclo de vida ----------
          function start() {
            reset();
            S.running = true;

            const titleEl = document.getElementById("title");
            const subtitleEl = document.getElementById("subtitle");
            const statsEl = document.getElementById("stats");

            if (titleEl) titleEl.replaceChildren("¬°A correr!");
            if (subtitleEl)
              subtitleEl.textContent =
                "Evita obst√°culos, atrapa estrellas. Toca / Espacio / ‚Üë para saltar. Doble salto habilitado.";
            if (statsEl) statsEl.style.display = "none";
            if (rewardBtn) rewardBtn.style.display = "none";
            if (overlay) overlay.classList.remove("show");

            if (bgm && audioReady && !muted) bgm.play().catch(() => {});
          }

          function over() {
            S.running = false;

            const finalPoints = Math.floor(S.score);
            if (finalPoints > S.best) {
              S.best = finalPoints;
              localStorage.setItem("bestPoints", String(S.best));
            }

            const titleEl = document.getElementById("title");
            const subtitleEl = document.getElementById("subtitle");
            const statsEl = document.getElementById("stats");

            if (titleEl) {
              const im = new Image();
              im.src = assets.gameOverImg;
              im.alt = "Game Over";
              im.loading = "lazy";
              im.decoding = "async";
              im.style.display = "block";
              im.style.margin = "12px auto 0";
              im.style.maxWidth = "clamp(200px, 50%, 400px)";
              im.style.height = "auto";
              titleEl.replaceChildren(im);
            }

            if (subtitleEl) {
              subtitleEl.textContent =
                "Pulsa Enter / clic / tap para reiniciar.";
            }

            if (statsEl) {
              statsEl.innerHTML = `Puntos: <b>${finalPoints}</b> ¬∑ Distancia: <b>${Math.floor(S.meters)}</b> m ¬∑ R√©cord: <b>${S.best}</b>`;
              statsEl.style.display = "block";
            }

            if (overlay) overlay.classList.add("show");
            canRestartAt = performance.now() + 600;

            playSfx("sfxOver");
          }

          // Mostrar overlay al cargar
          if (overlay) overlay.classList.add("show");
        })();
      });
    </script>
  </body>
</html>
