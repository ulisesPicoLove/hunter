<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Humbe runner</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        background: #111;
        font-family:
          system-ui,
          Segoe UI,
          Roboto,
          Arial;
      }
      body {
        touch-action: manipulation;
        overscroll-behavior: none;
      }
      #wrap {
        min-height: 100vh;
        display: grid;
        place-items: center;
      }
      @supports (min-height: 100dvh) {
        #wrap {
          min-height: 100dvh;
        }
      }

      /* Canvas 16:9 responsive */
      canvas {
        display: block;
        border-radius: 12px;
        box-shadow: 0 10px 28px #0006;
        aspect-ratio: 16/9;
        width: min(100vw, calc(100vh * (16 / 9)));
        height: auto;
        max-width: 100vw;
        max-height: 100vh;
      }
      @supports (width: 100svw) {
        canvas {
          width: min(100svw, calc(100svh * (16 / 9)));
          max-width: 100svw;
          max-height: 100svh;
        }
      }
      @supports (width: 100dvw) {
        canvas {
          width: min(100dvw, calc(100dvh * (16 / 9)));
          max-width: 100dvw;
          max-height: 100dvh;
        }
      }

      .hud {
        position: fixed;
        top: 10px;
        left: 0;
        right: 0;
        display: flex;
        justify-content: center;
        gap: 8px;
        pointer-events: none;
      }
      .card {
        background: #fff;
        color: #222;
        padding: 6px 10px;
        border-radius: 12px;
        font-weight: 700;
      }
      /* Bot√≥n de sonido s√≠ recibe clics */
      #muteBtn {
        pointer-events: auto;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        user-select: none;
      }
      #muteBtn[aria-pressed="true"] {
        background: #222;
        color: #ffd33d;
        outline: 2px solid #ffd33d;
      }

      .overlay {
        position: fixed;
        inset: 0;
        display: none;
        place-items: center;
        background: #0007;
        color: #fff;
        text-align: center;
        padding: 20px;
      }
      .overlay.show {
        display: grid;
      }
      .btn {
        display: inline-block;
        margin-top: 10px;
        padding: 10px 14px;
        border-radius: 12px;
        background: #ffd33d;
        color: #000;
        font-weight: 800;
        cursor: pointer;
        user-select: none;
      }
      .stats {
        font-weight: 700;
        font-size: 18px;
        margin: 8px 0 4px;
      }
      #jumpBtn {
        position: fixed;
        right: 14px;
        bottom: 14px;
        padding: 16px 18px;
        border-radius: 999px;
        background: #ffd33d;
        color: #000;
        font-weight: 900;
        box-shadow: 0 6px 18px #0006;
        user-select: none;
      }
      #title img {
        display: block;
        margin: 12px auto 0;
        max-width: min(92vw, 480px);
        height: auto;
      }
      @media (min-width: 720px) {
        #jumpBtn {
          display: none;
        }
      }

      /* Estilo para la imagen bajo el t√≠tulo en Game Over */
      #title img {
        display: block;
        margin: 12px auto 0;
        max-width: min(92vw, 480px);
        height: auto;
      }
    </style>
  </head>
  <body>
    <div id="wrap">
      <canvas id="game"></canvas>

      <div class="hud">
        <div class="card">Puntos <span id="points">0</span></div>
        <div class="card">Distancia <span id="meters">0</span> m</div>
        <div class="card">ü•á <span id="best">0</span></div>
        <button
          id="muteBtn"
          class="card"
          type="button"
          aria-pressed="false"
          aria-label="Silenciar sonido">
          üîä Sonido
        </button>
      </div>

      <div id="overlay" class="overlay">
        <div>
          <h1 id="title">
            <img
              src="assets/caza.webp"
              alt="Bienvenido a Humbe Runner"
              loading="eager"
              decoding="async" />
          </h1>
          <p id="subtitle">
            Evita obst√°culos y atrapa
            <img src="assets/Star.png" width="30" alt="" />
            <img src="assets/GoodCloud.webp" width="30" alt="" />. <br />Toca /
            Espacio / ‚Üë para saltar. Doble salto habilitado.
          </p>
          <p id="stats" class="stats" style="display: none"></p>
          <div class="btn" id="startBtn">Jugar</div>
        </div>
      </div>

      <div id="jumpBtn" role="button" aria-label="Saltar">‚§¥Ô∏é</div>
    </div>

    <!-- üîä AUDIO: ambientaci√≥n y SFX  -->
    <audio id="bgm" src="assets/sound.mp3" preload="auto" loop></audio>
    <audio id="sfxJump" src="assets/jump.mp3" preload="auto"></audio>
    <audio id="sfxStar" src="assets/collect.mp3" preload="auto"></audio>
    <audio id="sfxBonus" src="assets/point.mp3" preload="auto"></audio>
    <audio id="sfxOver" src="assets/lose.mp3" preload="auto"></audio>

    <script>
      (() => {
        // ---------- Canvas ----------
        const c = document.getElementById("game");
        const ctx = c.getContext("2d", { alpha: true });

        const V = { W: 960, H: 540, aspect: 16 / 9 };

        let DPR = 1,
          SCALE = 1;
        function getViewportSize() {
          const vw = Math.floor(
            window.visualViewport?.width ?? window.innerWidth
          );
          const vh = Math.floor(
            window.visualViewport?.height ?? window.innerHeight
          );
          return { vw, vh };
        }
        function fit() {
          DPR = Math.min(2, window.devicePixelRatio || 1);
          const { vw, vh } = getViewportSize();
          SCALE = Math.min(vw / V.W, vh / V.H);
          c.style.width = V.W * SCALE + "px";
          c.style.height = V.H * SCALE + "px";
          c.width = Math.round(V.W * DPR);
          c.height = Math.round(V.H * DPR);
          ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        }
        addEventListener("resize", fit, { passive: true });
        addEventListener("orientationchange", fit, { passive: true });
        if (window.visualViewport)
          visualViewport.addEventListener("resize", fit, { passive: true });
        fit();

        // Helpers
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const rand = (a, b) => a + Math.random() * (b - a);
        function safeDraw(imgEl, ...args) {
          if (!imgEl || !imgEl.complete || imgEl.naturalWidth === 0) return;
          ctx.drawImage(imgEl, ...args);
        }
        function bubbleTarget() {
          const p = S.player;
          return { x: p.x + p.w * 0.55, y: p.y - p.h - 50 };
        }

        // ---------- Generadores demo (backup) ----------
        function makeCanvas(w, h, draw) {
          const cc = document.createElement("canvas");
          cc.width = w;
          cc.height = h;
          const cx = cc.getContext("2d");
          draw(cx, w, h);
          return cc.toDataURL("image/png");
        }
        const demo = {
          bg: makeCanvas(V.W, V.H, (x, w, h) => {
            const g = x.createLinearGradient(0, 0, 0, h);
            g.addColorStop(0, "#9eeeff");
            g.addColorStop(1, "#7bd4ff");
            x.fillStyle = g;
            x.fillRect(0, 0, w, h);
          }),
          star: makeCanvas(64, 64, (x, w, h) => {
            x.translate(w / 2, h / 2);
            x.rotate(0.2);
            x.fillStyle = "#ffd33d";
            x.beginPath();
            const r = 22;
            for (let i = 0; i < 5; i++) {
              const a = (i * 2 * Math.PI) / 5;
              const ax = Math.cos(a) * r,
                ay = Math.sin(a) * r;
              const bx = Math.cos(a + Math.PI / 5) * r * 0.5,
                by = Math.sin(a + Math.PI / 5) * r * 0.5;
              i ? x.lineTo(ax, ay) : x.moveTo(ax, ay);
              x.lineTo(bx, by);
            }
            x.closePath();
            x.fill();
            x.strokeStyle = "#c99b1a";
            x.lineWidth = 2;
            x.stroke();
          }),
        };

        // ---------- ASSETS ----------
        const assets = {
          bg: "assets/SkyBack.webp",
          ground: "assets/baseFront.webp",
          groundFront: "assets/base.webp",
          star: "assets/Star.webp",
          starBonus: "assets/GoodCloud.webp",
          obstacle: "assets/Rayo.webp",
          meteor: "assets/meteorito.webp", // 500x401
          bird: "assets/BadCloud.webp",
          player: {
            runL: "assets/Humbeleft.webp",
            runR: "assets/HumbeRigth.webp",
            jump: "assets/HumbeJump.webp",
          },
          gameOverImg: "assets/GAMEOVER.webp", // <- imagen para Game Over
        };
        const gameOverPreload = new Image();
        gameOverPreload.src = assets.gameOverImg; // aseg√∫rate de tener esta ruta definida

        function loadImage(src) {
          const i = new Image();
          i.src = src;
          return i;
        }
        const img = {
          bg: loadImage(assets.bg),
          ground: loadImage(assets.ground),
          groundFront: loadImage(assets.groundFront),
          star: loadImage(assets.star),
          starBonus: loadImage(assets.starBonus),
          obstacle: loadImage(assets.obstacle),
          meteor: loadImage(assets.meteor),
          bird: loadImage(assets.bird),
          player: {
            runL: loadImage(assets.player.runL),
            runR: loadImage(assets.player.runR),
            jump: loadImage(assets.player.jump),
          },
        };

        // ---------- Constantes sprites ----------
        const METEOR_W = 500,
          METEOR_H = 401,
          METEOR_AR = METEOR_W / METEOR_H;
        const PLAYER_VOFFSET = 6,
          BLOCK_VOFFSET = 6;

        // ---------- F√≠sica / Juego ----------
        const G = {
          gravity: 2200,
          jumpV: 860,
          groundY: () => V.H * 0.78,
          baseSpeed: 290,
          maxSpeed: 1000,
          speedUpEach: 14,
          speedUpDelta: 28,
          starEvery: [1.0, 2.0],
          obsEvery: [1.5, 3.2],
        };

        // Aparici√≥n + movimiento de la nube bonus
        const BONUS = {
          prob: 0.18,
          speedMul: 1.4,
          ampX: 18,
          ampY: 66,
          freq: 1.8,
          driftY: -12,
          jitter: 22,
        };

        /* ============================================================
         *  TAMA√ëOS INDEPENDIENTES: estrella vs bonus
         *  - collisionR: radio de colisi√≥n (jugabilidad)
         *  - visualScale / visualW / visualH: tama√±o solo visual
         * ============================================================ */
        const STAR_SIZE = {
          collisionR: 22, // radio de colisi√≥n de estrella
          visualScale: 1.2, // 1 = igual; >1 m√°s grande visualmente
        };
        const BONUS_SIZE = {
          collisionR: 26, // radio de colisi√≥n del bonus (nube)
          visualW: 3.2, // ancho visual relativo al radio
          visualH: 1.6, // alto visual relativo al radio
        };

        // ---------- Frases (bubble) ----------
        const PHRASES = Array.isArray(window.PHRASES)
          ? window.PHRASES
          : [
              "¬°Lo que tocas, oro se hace!",
              "¬°Eres lo que el Sol siempre quiso ser!",
              "¬°Ponte cerca pa‚Äô dec√≠rtelo al o√≠do: te necesito!",
              "¬°Yo espero por tu llegada!",
              "¬°Tan fr√≠o y aun as√≠ me arde!",
              "¬°Por ti, yo muevo el planeta completo!",
              "¬°Si el amor no quema, no es amar!",
              "¬°No me temas, soy extraordinario!",
              "¬°D√©jame, en besos, recorrer tu piel!",
              "¬°Nos hacemos eternos!",
              "¬°T√∫ eres para m√≠!",
              "¬°Contigo, yo volv√≠ a respirar!",
              "¬°Amarrado en tus besos y en tu piel!",
              "¬°Diez mil kil√≥metros descalzo correr√≠a, todo dar√≠a por que fueras m√≠a!",
              "¬°A veces, no me siento yo!",
              "¬°Ten la confianza y busca la vida!",
              "¬°Respira, que todo se alivia!",
              "¬°Perderte es vivir sin mi propia esencia!",
              "¬°El tiempo pasa r√°pido y lento!",
              "¬°Necesito volver a encontrarte!",
            ];
        function makeShuffledBag(arr) {
          const a = (Array.isArray(arr) ? arr : []).filter((v) => v != null); // limpia null/undefined

          // Fisher‚ÄìYates
          for (let i = a.length - 1; i > 0; i--) {
            const j = (Math.random() * (i + 1)) | 0;
            const tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
          }
          return a;
        }

        // ---------- üîä AUDIO ----------
        const muteBtn = document.getElementById("muteBtn");
        const bgm = document.getElementById("bgm");
        let audioReady = false;
        let muted = localStorage.getItem("humbe_muted") === "1";
        function updateMuteButton() {
          if (!muteBtn) return;
          muteBtn.setAttribute("aria-pressed", muted ? "true" : "false");
          muteBtn.textContent = muted ? "üîá Silenciado" : "üîä Sonido";
          if (bgm) bgm.muted = muted;
        }
        updateMuteButton();

        async function unlockAudio() {
          if (audioReady) return;
          audioReady = true;
          try {
            if (bgm) {
              bgm.volume = 0.5;
              if (!muted) await bgm.play();
            }
          } catch {}
        }
        function playSfx(id) {
          if (muted || !audioReady) return;
          const a = document.getElementById(id);
          if (!a) return;
          try {
            a.currentTime = 0;
            a.play();
          } catch {}
        }
        if (muteBtn) {
          muteBtn.addEventListener("click", async () => {
            muted = !muted;
            try {
              localStorage.setItem("humbe_muted", muted ? "1" : "0");
            } catch {}
            updateMuteButton();
            if (bgm) {
              if (!muted && audioReady) {
                try {
                  await bgm.play();
                } catch {}
              } else {
                bgm.pause();
              }
            }
          });
        }

        // ---------- Estado ----------
        let S;
        let canRestartAt = 0; // ‚õî cooldown de reinicio tras Game Over

        function reset() {
          S = {
            t: 0,
            running: false,
            score: 0,
            meters: 0,
            stars: 0,
            best: Number(localStorage.getItem("bestPoints") || 0),
            speed: G.baseSpeed,
            lastStar: 0,
            lastObs: 0,
            lastSpeedUp: 0,
            jumps: 0,
            player: {
              x: 120,
              y: G.groundY(),
              w: 72,
              h: 72,
              vy: 0,
              onGround: true,
              state: "runL",
              frameTimer: 0,
              runFps: 10,
            },
            obs: [],
            items: [],
            particles: [],
            front: {
              x: 0,
              speedMul: 1.15,
              y: G.groundY() - 0,
              h: 120,
              alpha: 1,
            },
            groundScroll: { x: 0, y: V.H * 0.66, h: 120, speedPx: 80 },
            bubble: null,
            phraseBag: makeShuffledBag(PHRASES || []),
          };
        }
        reset();
        function nextPhrase() {
          if (!Array.isArray(PHRASES) || PHRASES.length === 0) return "";
          if (!S.phraseBag || S.phraseBag.length === 0) {
            S.phraseBag = makeShuffledBag(PHRASES);
          }
          const msg = S.phraseBag.pop();
          return typeof msg === "string" ? msg : "";
        }

        // ---------- Input ----------
        function jump() {
          if (!S.running) return;
          const p = S.player;
          if (p.onGround || S.jumps < 2) {
            p.vy = -G.jumpV;
            p.onGround = false;
            S.jumps++;
            p.state = "jump";
            playSfx("sfxJump");
          }
        }
        addEventListener("keydown", (e) => {
          if (["Space", "Enter", "ArrowUp"].includes(e.code))
            e.preventDefault();
          if (e.code === "ArrowUp") {
            unlockAudio();
            jump();
          }

          if (!S.running && (e.code === "Space" || e.code === "Enter")) {
            if (performance.now() >= canRestartAt) {
              unlockAudio();
              start();
            }
          }
        });
        c.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          if (S.running) {
            unlockAudio();
            jump();
          }
        });

        const overlay = document.getElementById("overlay");
        const subtitleEl = document.getElementById("subtitle");
        const statsEl = document.getElementById("stats");
        const startBtn = document.getElementById("startBtn");
        if (startBtn)
          startBtn.onclick = () => {
            unlockAudio();
            start();
          };

        // Permite reiniciar con clic en overlay tras cooldown
        if (overlay) {
          overlay.addEventListener("pointerdown", (e) => {
            if (!S.running && performance.now() >= canRestartAt) {
              unlockAudio();
              start();
            }
          });
        }

        const rewardBtn = (() => {
          let btn = document.getElementById("rewardBtn");
          if (!btn && overlay) {
            btn = document.createElement("div");
            btn.id = "rewardBtn";
            btn.className = "btn";
            btn.style.display = "none";
            btn.textContent = "Recompensa ";
            btn.onclick = () => {
              if (!S.running && performance.now() >= canRestartAt) start();
            };
            const container = overlay.firstElementChild || overlay;
            container.appendChild(btn);
          }
          return btn;
        })();

        // ---------- Spawns ----------
        function spawn(dt) {
          S.lastStar += dt;
          S.lastObs += dt;
          S.lastSpeedUp += dt;

          if (S.lastSpeedUp >= G.speedUpEach) {
            S.speed = Math.min(G.maxSpeed, S.speed + G.speedUpDelta);
            S.lastSpeedUp = 0;
          }

          if (S.lastStar >= rand(...G.starEvery)) {
            const isBonus = Math.random() < BONUS.prob;
            S.items.push({
              type: isBonus ? "bonus" : "star",
              x: V.W + 40,
              y: rand(V.H * 0.5, V.H * 0.72),

              // radios de colisi√≥n independientes
              r: isBonus ? BONUS_SIZE.collisionR : STAR_SIZE.collisionR,

              // props visuales SIEMPRE definidas (evita NaN)
              vScale: isBonus ? 1 : STAR_SIZE.visualScale || 1,
              vW: isBonus ? BONUS_SIZE.visualW || 3.2 : 0,
              vH: isBonus ? BONUS_SIZE.visualH || 1.6 : 0,

              vx: S.speed * (isBonus ? BONUS.speedMul : 1.0),
              t: 0,
              phase: rand(0, Math.PI * 2),
              ampX: BONUS.ampX * rand(0.6, 1.4),
              ampY: BONUS.ampY * rand(0.6, 1.4),
              freq: BONUS.freq * rand(0.7, 1.3),
              driftY: BONUS.driftY * rand(0.6, 1.4),
              jitter: BONUS.jitter,
            });
            S.lastStar = 0;
          }

          if (S.lastObs >= rand(...G.obsEvery)) {
            const r = Math.random();
            if (r < 0.55) {
              S.obs.push({
                type: "block",
                x: V.W + 40,
                y: G.groundY(),
                w: 60,
                h: 60,
                vx: S.speed,
              });
            } else if (r < 0.85) {
              S.obs.push({
                type: "bird",
                x: V.W + 40,
                y: rand(V.H * 0.52, V.H * 0.64),
                w: 60,
                h: 40,
                vx: S.speed,
                flap: 0,
              });
            } else {
              const startX = rand(V.W * 0.7, V.W + 80),
                startY = rand(-120, -40);
              const speed = rand(380, 520),
                fall = rand(280, 380);
              const destH = 26 * 2.3,
                destW = destH * METEOR_AR;
              S.obs.push({
                type: "meteor",
                x: startX,
                y: startY,
                vx: speed,
                vy: fall,
                dw: destW,
                dh: destH,
                rcx: -0.24,
                rcy: 0.08,
                rr: 0.18,
              });
            }
            S.lastObs = 0;
          }
        }

        // ---------- Colisiones / part√≠culas ----------
        const clampR = (cx, cy, r, rx, ry, rw, rh) => {
          const nx = clamp(cx, rx, rx + rw),
            ny = clamp(cy, ry, ry + rh);
          const dx = cx - nx,
            dy = cy - ny;
          return dx * dx + dy * dy <= r * r;
        };
        const aabb = (a, b) =>
          a.x < b.x + b.w &&
          a.x + a.w > b.x &&
          a.y < b.y + b.h &&
          a.y + a.h > b.y;

        function puff(x, y, n = 6) {
          for (let i = 0; i < n; i++) {
            S.particles.push({
              type: "note",
              x,
              y,
              vx: rand(-120, 120),
              vy: rand(-220, -80),
              s: rand(18, 28),
              rot: rand(-0.35, 0.35),
              life: rand(0.8, 1.2),
            });
          }
        }

        // ---------- Loop ----------
        let last = performance.now();
        function loop(now) {
          try {
            const dt = Math.min((now - last) / 1000, 0.033);
            last = now;
            if (S.running) update(dt);
            draw();
          } catch (err) {
            console.error(err);
            const overlay = document.getElementById("overlay");
            const statsEl = document.getElementById("stats");
            if (overlay) overlay.classList.add("show");
            if (statsEl) {
              statsEl.style.display = "block";
              statsEl.textContent =
                "Error: " + (err && err.message ? err.message : String(err));
            }
          }
          requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

        function update(dt) {
          S.t += dt;
          S.meters += S.speed * dt * 0.06;

          if (S.bubble && S.bubble.lockToPlayer) {
            const t = bubbleTarget();
            const followSpeed = 12;
            S.bubble.x += (t.x - S.bubble.x) * Math.min(1, dt * followSpeed);
            S.bubble.y += (t.y - S.bubble.y) * Math.min(1, dt * followSpeed);
            S.bubble.x = clamp(S.bubble.x, 16, V.W - 16);
            S.bubble.y = clamp(S.bubble.y, 16, V.H - 16);
          }

          const p = S.player;
          // f√≠sica
          p.vy += G.gravity * dt;
          p.y += p.vy * dt;
          if (p.y > G.groundY()) {
            p.y = G.groundY();
            p.vy = 0;
            p.onGround = true;
            S.jumps = 0;
            if (p.state === "jump") p.state = "runL";
          } else p.onGround = false;

          // animaci√≥n
          if (p.onGround) {
            p.frameTimer += dt;
            if (p.frameTimer >= 1 / p.runFps) {
              p.state = p.state === "runL" ? "runR" : "runL";
              p.frameTimer = 0;
            }
          } else p.state = "jump";

          spawn(dt);

          // mover obs/items
          S.obs.forEach((o) => {
            if (o.type === "bird" || o.type === "block") {
              o.x -= o.vx * dt;
              if (o.type === "bird") {
                o.flap += dt * 9;
                o.y += Math.sin(S.t * 4 + o.x * 0.02) * 0.6;
              }
            } else if (o.type === "meteor") {
              o.x -= o.vx * dt;
              o.y += o.vy * dt;
            }
          });
          S.items.forEach((i) => {
            i.x -= i.vx * dt;
            if (i.type === "bonus") {
              i.t += dt;
              i.x += Math.cos(i.phase + i.t * i.freq) * (i.ampX * dt);
              i.y += Math.sin(i.phase * 0.7 + i.t * i.freq) * (i.ampY * dt);
              i.y += i.driftY * dt;
              if (Math.random() < 0.05) i.y += rand(-i.jitter, i.jitter) * 0.05;
              i.y = clamp(i.y, V.H * 0.35, V.H * 0.78);
            }
          });

          // mover capa frontal
          S.front.x -= S.speed * S.front.speedMul * dt;
          if (S.front.x <= -V.W) S.front.x += V.W;

          // mover ground independiente
          S.groundScroll.x -= S.groundScroll.speedPx * dt;
          if (S.groundScroll.x <= -V.W) S.groundScroll.x += V.W;

          // jugador rect colisi√≥n
          const pr = {
            x: p.x + p.w * 0.15,
            y: p.y - p.h + 5,
            w: p.w * 0.7,
            h: p.h - 10,
          };

          // estrellas (normal/bonus)
          for (let i = S.items.length - 1; i >= 0; i--) {
            const s = S.items[i];
            if (clampR(s.x, s.y, s.r, pr.x, pr.y, pr.w, pr.h)) {
              S.stars++;
              if (s.type === "bonus") {
                S.score += 120;
                puff(s.x, s.y, 16);
                S.particles.push({
                  x: s.x,
                  y: s.y - 60,
                  vx: 0,
                  vy: -60,
                  r: 0,
                  life: 0.8,
                  text: "+120",
                  color: "#ffd33d",
                  stroke: "#3b2f00",
                });
                playSfx("sfxBonus");
              } else {
                S.score += 10;
                puff(s.x, s.y, 10);
                playSfx("sfxStar");
              }

              if (S.stars % 4 === 0) {
                const msg = nextPhrase();
                const t = bubbleTarget();
                S.bubble = {
                  text: msg,
                  time: 3.3,
                  x: t.x,
                  y: t.y,
                  lockToPlayer: true,
                };
              }
              S.items.splice(i, 1);
            } else if (s.x < -80) S.items.splice(i, 1);
          }

          // colisiones letales
          for (const o of S.obs) {
            if (o.type === "meteor") {
              const mw = o.dw ?? (o.dh ? o.dh * METEOR_AR : METEOR_W);
              const mh = o.dh ?? (o.dw ? o.dw / METEOR_AR : METEOR_H);
              const cx = o.x + mw * (o.rcx ?? -0.24);
              const cy = o.y + mh * (o.rcy ?? 0.08);
              const rr = mh * (o.rr ?? 0.18);
              if (clampR(cx, cy, rr, pr.x, pr.y, pr.w, pr.h)) return over();
              continue;
            }
            const ob = {
              x: o.x + o.w * 0.1,
              y: o.y - o.h,
              w: o.w * 0.8,
              h: o.h,
            };
            if (aabb(pr, ob)) {
              if (o.type === "bird" && p.y < o.y - o.h / 2) continue;
              return over();
            }
          }

          // limpiar y part√≠culas
          S.obs = S.obs.filter((o) => o.x > -120 && o.y < V.H + 140);
          for (let i = S.particles.length - 1; i >= 0; i--) {
            const pa = S.particles[i];
            pa.life -= dt;
            if (pa.life <= 0) {
              S.particles.splice(i, 1);
              continue;
            }
            pa.x += pa.vx * dt;
            pa.y += pa.vy * dt;
            pa.vy += 900 * dt;
          }

          if (S.bubble) {
            S.bubble.time -= dt;
            if (S.bubble.time <= 0) S.bubble = null;
          }
        }

        // ---------- Dibujo ----------
        function drawMeteorProportional(o) {
          const m = img.meteor,
            iw = m.width || METEOR_W,
            ih = m.height || METEOR_H;
          const DW = o.dw ?? (o.dh ? o.dh * METEOR_AR : iw);
          const DH = o.dh ?? (o.dw ? o.dw / METEOR_AR : ih);
          safeDraw(m, 0, 0, iw, ih, o.x - DW / 2, o.y - DH / 2, DW, DH);
        }
        function drawTiled(image, x, y, h) {
          const tex =
            image && image.complete && image.naturalWidth ? image : img.ground;
          let x0 = Math.floor(x);
          while (x0 > 0) x0 -= V.W;
          for (let xx = x0; xx < V.W; xx += V.W) safeDraw(tex, xx, y, V.W, h);
        }
        function drawSpeechBubble(text, x, y, maxW = 220) {
          ctx.font = "bold 14px system-ui, Arial";
          const words = String(text).split(/\s+/);
          const lines = [];
          let line = "";
          for (const w of words) {
            const t = line ? line + " " + w : w;
            if (ctx.measureText(t).width <= maxW) line = t;
            else {
              if (line) lines.push(line);
              line = w;
            }
          }
          if (line) lines.push(line);
          const lh = 22,
            padX = 12,
            padY = 10;
          const w = Math.min(
            maxW,
            Math.max(...lines.map((t) => ctx.measureText(t).width)) + padX * 2
          );
          const h = lines.length * lh + padY * 2;
          const rx = x - w / 2,
            ry = y - h,
            r = 10;

          ctx.save();
          ctx.beginPath();
          ctx.moveTo(rx + r, ry);
          ctx.lineTo(rx + w - r, ry);
          ctx.quadraticCurveTo(rx + w, ry, rx + w, ry + r);
          ctx.lineTo(rx + w, ry + h - r);
          ctx.quadraticCurveTo(rx + w, ry + h, rx + w - r, ry + h);
          const tipX = x + 12,
            tipY = ry + h + 8;
          ctx.lineTo(tipX, ry + h);
          ctx.lineTo(x, tipY);
          ctx.lineTo(x - 12, ry + h);
          ctx.lineTo(rx + r, ry + h);
          ctx.quadraticCurveTo(rx, ry + h, rx, ry + h - r);
          ctx.lineTo(rx, ry + r);
          ctx.quadraticCurveTo(rx, ry, rx + r, ry);
          ctx.closePath();

          ctx.shadowColor = "#0008";
          ctx.shadowBlur = 8;
          ctx.fillStyle = "#f2f2f2";
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.lineWidth = 1;
          ctx.strokeStyle = "#faf";
          ctx.stroke();

          ctx.fillStyle = "#111";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          let yy = ry + padY + lh / 2;
          for (const ln of lines) {
            ctx.fillText(ln, x, yy);
            yy += lh;
          }
          ctx.restore();
        }

        function draw() {
          ctx.clearRect(0, 0, V.W, V.H);

          // Fondo
          safeDraw(img.bg, 0, 0, V.W, V.H);

          // Ground independiente
          drawTiled(
            img.ground,
            S.groundScroll.x,
            S.groundScroll.y,
            S.groundScroll.h
          );

          // Estrellas / Bonus (robusto con fallbacks)
          for (const s of S.items) {
            const isBonus = s.type === "bonus";
            const spr = isBonus ? img.starBonus : img.star;

            if (isBonus) {
              const vW = s.vW || 3.2,
                vH = s.vH || 1.6;
              const w = s.r * vW,
                h = s.r * vH;
              safeDraw(spr, s.x - w / 2, s.y - h / 2, w, h);
            } else {
              const scale = s.vScale || 1;
              const rr = s.r * scale;
              safeDraw(spr, s.x - rr, s.y - rr, rr * 2, rr * 2);
            }
          }

          // Obst√°culos
          for (const o of S.obs) {
            if (o.type === "bird") {
              safeDraw(img.bird, o.x, o.y - o.h, o.w, o.h);
            } else if (o.type === "meteor") {
              drawMeteorProportional(o);
            } else {
              safeDraw(img.obstacle, o.x, o.y - o.h + BLOCK_VOFFSET, o.w, o.h);
            }
          }

          // Jugador
          const p = S.player;
          const sprite =
            p.state === "runL"
              ? img.player.runL
              : p.state === "runR"
                ? img.player.runR
                : img.player.jump;
          ctx.save();
          const tilt = p.onGround ? 0 : clamp(p.vy / 900, -0.6, 0.6);
          ctx.translate(p.x + p.w / 2, p.y - p.h / 2 + PLAYER_VOFFSET);
          ctx.rotate(tilt);
          safeDraw(sprite, -p.w / 2, -p.h / 2, p.w, p.h);
          ctx.restore();

          // Bubble
          if (S.bubble) drawSpeechBubble(S.bubble.text, S.bubble.x, S.bubble.y);

          // Part√≠culas
          for (const pa of S.particles) {
            ctx.globalAlpha = Math.max(0, Math.min(1, pa.life));
            if (pa.text) {
              ctx.font = "bold 20px system-ui, Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillStyle = pa.color || "#a3f";
              ctx.fillText(pa.text, pa.x, pa.y);
            } else {
              ctx.save();
              ctx.translate(pa.x, pa.y);
              ctx.rotate(pa.rot || 0);
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.font = `bold ${Math.round(pa.s)}px system-ui, Apple Color Emoji, Segoe UI Emoji, Arial`;
              ctx.fillStyle = "#ffd33d";
              ctx.strokeStyle = "#c99b1a";
              ctx.lineWidth = 2;
              const glyph = "‚ô™";
              ctx.fillText(glyph, 0, 0);
              ctx.strokeText(glyph, 0, 0);
              ctx.restore();
            }
            ctx.globalAlpha = 1;
          }

          // Capa frontal
          drawTiled(img.groundFront, S.front.x, S.front.y, S.front.h);

          // HUD
          const pointsEl = document.getElementById("points");
          if (pointsEl) pointsEl.textContent = Math.floor(S.score);
          const metersEl = document.getElementById("meters");
          if (metersEl) metersEl.textContent = Math.floor(S.meters);
          const bestEl = document.getElementById("best");
          if (bestEl) bestEl.textContent = S.best;
        }

        // ---------- Ciclo de vida ----------
        function start() {
          reset();
          S.running = true;

          const titleEl = document.getElementById("title");
          const subtitleEl = document.getElementById("subtitle");
          const statsEl = document.getElementById("stats");

          // Vuelve al texto normal del inicio
          if (titleEl) titleEl.replaceChildren("¬°A correr!");
          if (subtitleEl)
            subtitleEl.textContent =
              "Evita obst√°culos, atrapa estrellas. Toca / Espacio / ‚Üë para saltar. Doble salto habilitado.";
          if (statsEl) statsEl.style.display = "none";
          if (rewardBtn) rewardBtn.style.display = "none";
          if (overlay) overlay.classList.remove("show");

          if (bgm && audioReady && !muted) bgm.play().catch(() => {});
        }

        function over() {
          S.running = false;

          const finalPoints = Math.floor(S.score);
          if (finalPoints > S.best) {
            S.best = finalPoints;
            localStorage.setItem("bestPoints", String(S.best));
          }

          const titleEl = document.getElementById("title");
          const subtitleEl = document.getElementById("subtitle");
          const statsEl = document.getElementById("stats");

          // ‚¨áÔ∏è SOLO IMAGEN (sin texto)
          if (titleEl) {
            const img = new Image();
            img.src = assets.gameOverImg;
            img.alt = "Game Over";
            img.loading = "lazy";
            img.decoding = "async";
            img.style.display = "block";
            img.style.margin = "12px auto 0";
            img.style.maxWidth = "min(92vw, 480px)";
            img.style.height = "auto";
            titleEl.replaceChildren(img);
          }

          if (subtitleEl) {
            subtitleEl.textContent = "Pulsa Enter / clic / tap para reiniciar.";
          }

          if (statsEl) {
            statsEl.innerHTML = `Puntos: <b>${finalPoints}</b> ¬∑ Distancia: <b>${Math.floor(
              S.meters
            )}</b> m ¬∑ R√©cord: <b>${S.best}</b>`;
            statsEl.style.display = "block";
          }

          // mostrar overlay, cooldown, sfx...
          if (overlay) overlay.classList.add("show");
          canRestartAt = performance.now() + 600;
          playSfx("sfxOver");
        }

        // Mostrar overlay al cargar
        if (overlay) overlay.classList.add("show");
      })();
    </script>
  </body>
</html>
